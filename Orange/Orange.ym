%glr-parser
%define api.pure

%code requires {	
	#define YYDEBUG 1
	union YYSTYPE;
	#ifndef YY_TYPEDEF_YY_SCANNER_T
	typedef void * yyscan_t ;
	#endif
	
	#import "OrangeTarget.h"
	#import "OrangeExpression.h"
	#import "OrangeBinding.h"
	#import "OrangeScript_Private.h"

	#import "NSObject+Orange.h"
	#import <objc/runtime.h>
	
	int yylex ( union YYSTYPE * lvalp, yyscan_t scanner, va_list argList );
	void yyerror( yyscan_t scanner, id selfObject, va_list argList, OrangeScript ** result, const char * error ) ;
	
	typedef OrangeExpression * ExprPtr ;
	typedef OrangeTarget * TargetPtr ;
}

%parse-param { yyscan_t scanner }
%parse-param { id selfObject }
%parse-param { va_list argList }
%parse-param { OrangeScript ** result }
%lex-param { yyscan_t scanner }
%lex-param { va_list argList }

%token <number> NUM
%token <selector> SELECTOR0
%token <selector> SELECTOR1
%token <selector> SELECTOR2
%token <string> KEY
%token <string> STRING
%token BIND
%token SELF
%token OBJ
%token MAX
%token MIN
%token SUM
%token SIZE
%token RECT
%token INSETS
%token POINT
%token <string> TRIGGER
%token SCOPEBEGIN
%token SCOPEEND

%type <target>			target
%type <string>			keypath ;
%type <object>			object ;
%type <array>			exprlist ;
%type <expression>		expr ;
%type <context>			statement ;
%type <array>			statements ;
%type <binding>			binding ;
%type <array>			array ;
%type <array>			script ;	// array of OrangeBinding, OrangeTriggerScope, OrangeBindingScope
%type <array>			triggerlist ;

%union {
	NSNumber *					number ;
	SEL							selector;
	NSString *					key ;
	NSString *					string ;
	id							object ;
	OrangeExpression *			expression ;
	OrangeTarget *				target ;
	OrangeBinding *				binding ;
	OrangeBindingScope *		scope ;
	OrangeTriggerScope *		trigger ;
	NSArray *					array ;
//	NSOrderedSet *				orderedSet ;
	OrangeEvaluationContext *	context ;
}

%%

toplevel:		/* blank */
				{
					if ( result ) { *result = nil; } ;
				}
				| script
				{
					OrangeScript * script = [ [ [ OrangeScript alloc ] init ] autorelease ] ;
					script.contained = $1 ;
					*result = script ;
				}
;

script:			statement
				{
					$$ = [ NSArray arrayWithObject:$1 ] ;
				}
				| script statement
				{
					$$ = [ $1 arrayByAddingObject:$2 ] ;
				}
				
;

statement:		binding
				| target SCOPEBEGIN statements SCOPEEND
				{
					OrangeEvaluationContext * scope = [ [ [ OrangeEvaluationContext alloc ] init ] autorelease ] ;
					scope.target = $1 ;
					scope.contained = $3 ;
					
					$$ = scope ;
				}
				| triggerlist SCOPEBEGIN statements SCOPEEND
				{
					OrangeTriggerScope * scope = [ [ [ OrangeTriggerScope alloc ] init ] autorelease ] ;
					scope.triggers = $1 ;
					scope.contained = $3 ;
					
					$$ = scope ;
				}
;

triggerlist:	/**/
				TRIGGER
				{
					$$ = [ NSArray arrayWithObject:$1 ] ;
				}
				| triggerlist TRIGGER
				{
					$$ = [ $1 arrayByAddingObject:$2 ] ;
				}
;

statements:		/**/
				statement
				{
					$$ = [ NSArray arrayWithObject:$1 ] ;
				}
				| statements ';' statement
				{
					$$ = [ $1 arrayByAddingObject:$3 ] ;
				}
				| statements ',' statement
				{
					$$ = [ $1 arrayByAddingObject:$3 ] ;
				}
;

binding:		target BIND expr
				{
					OrangeBinding * binding = [ [ [ OrangeBinding alloc ] init ] autorelease ] ;
					binding.target = $1 ;
					binding.expression = $3 ;
					
					$$ = binding ;
				}
;

//bindings:		binding
//				{
//					$$ = [ NSArray arrayWithObject:$1 ] ;
//				}
//				| bindings ';' binding
//				{
//					$$ = [ $1 arrayByAddingObject:$3 ] ;
//				}

expr:			NUM							{ $$ = [ [ OrangeConstant alloc ] initWithValue:$1 ] ; }
				| STRING					{ $$ = [ [ OrangeConstant alloc ] initWithValue:$1 ] ; }
				| '+' expr expr				
				{
					ExprPtr expr0 = $2, expr1 = $3 ;
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						return [ expr0 floatResult:scope ] + [ expr1 floatResult:scope ] ;
					}];
				}
				| '-' expr expr				
				{ 
					ExprPtr expr0 = $2, expr1 = $3 ;
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						return [ expr0 floatResult:scope ] - [ expr1 floatResult:scope ] ;
					}];
				}
				| '*' expr expr				
				{ 
					ExprPtr expr0 = $2, expr1 = $3 ;
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						return [ expr0 floatResult:scope ] * [ expr1 floatResult:scope ] ;
					}];
				}
				| SUM expr
				{
					ExprPtr expr = $2 ;
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						__block CGFloat sum = 0.0f ;
						[ [ expr result:scope ] enumerateObjectsUsingBlock:^(OrangeExpression * expr, NSUInteger idx, BOOL *stop) {
							sum += [ expr floatResult:scope ] ;
						}];
						return sum ;
					}];
				}
				| MIN expr
				{
					ExprPtr expr = $2 ;				
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						__block CGFloat min = 0.0f ;
						[ [ expr result:scope ] enumerateObjectsUsingBlock:^(OrangeExpression * expr, NSUInteger idx, BOOL *stop) {
							min = MIN( min, [ expr floatResult:scope ] ) ;
						}];
						return min ;
					}];
				}
				| MAX expr
				{
					ExprPtr expr = $2 ;
					$$ = [ OrangeExpression expressionWithFloatEvaluator:^(id scope){
						__block CGFloat max = 0.0f ;
						[ [ expr result:scope ] enumerateObjectsUsingBlock:^(OrangeExpression * expr, NSUInteger idx, BOOL *stop) {
							max = MAX( max, [ expr floatResult:scope ] ) ;
						}];
						return max ;
					}];
				}
				| array 
				{ 
					[ NSException raise:OrangeParserException format:@"array literal not supported yet"];
				}
				| SELECTOR0 expr
				{
					SEL sel = $1 ;
					ExprPtr t = $2 ;
					$$ = [ OrangeExpression expressionWithEvaluator:^(id scope){
						return [ t performSelector:sel ] ;
					}];
				}
				| SELECTOR1 expr expr
				{
					SEL sel = $1 ;
					ExprPtr t = $2 ;
					ExprPtr expr0 = $3 ;
					$$ = [ OrangeExpression expressionWithEvaluator:^(id scope){
						return [ t performSelector:sel withObject:expr0 ] ;
					}];
				}
				| SELECTOR2 expr expr expr
				{
					SEL sel = $1 ;
					ExprPtr t = $2, expr0 = $3, expr1 = $4 ;
					$$ = [ OrangeExpression expressionWithEvaluator:^(id scope){
						return [ t performSelector:sel withObject:expr0 withObject:expr1 ] ;
					}];
				}
				| SIZE expr expr
				{	
					ExprPtr expr0 = $2, expr1 = $3 ;
					$$ = [ OrangeExpression expressionWithSizeEvaluator:^(id scope){
						return (CGSize){ [ expr0 floatResult:scope ], [ expr1 floatResult:scope ] } ;
					}];
				}
				| RECT expr expr expr expr
				{	
					ExprPtr expr0 = $2, expr1 = $3, expr2 = $4, expr3 = $5 ;
					$$ = [ OrangeExpression expressionWithRectEvaluator:^(id scope){
						return (CGRect){ { [ expr0 floatResult:scope ], [ expr1 floatResult:scope ] },
						{ [ expr2 floatResult:scope ], [ expr3 floatResult:scope ] } } ;
					} ];
				}
				| INSETS expr expr expr expr
				{
					[ NSException raise:OrangeParserException format:@"token INSETS not supported yet"];
				}
				| target
				{
					TargetPtr t = $1 ;
					$$ = [ OrangeExpression expressionWithEvaluator:^(id scope){
						id target = t.baseObject ;
						if ( !target ) { target = scope ; }
						return [ target valueForKeyPath:t.keypath ] ;
					} ] ;
				}
;

exprlist:		expr						
				{ 
					$$ = [ NSArray arrayWithObject:$1 ] ; 
				}
				| exprlist expr				
				{ 
					$$ = [ $1 arrayByAddingObject:$2 ] ; 
				}
;

object:			OBJ
				| SELF						{ $$ = selfObject ; }
;
				
target:			object						
				{ 
					$$ = [ [ OrangeTarget alloc ] initWithTarget:$1 keypath:nil ] ; 
				}
				| keypath					
				{ 
					NSString * keyPath = $1 ;
					$$ = [ [ OrangeTarget alloc ] initWithTarget:nil keypath:keyPath ] ; 
				}
				| object keypath			
				{ 
					$$ = [ [ OrangeTarget alloc ] initWithTarget:$1 keypath:$2 ] ; 
				}
;

keypath:		KEY
				| keypath KEY				
				{ 
					$$ = [ $1 stringByAppendingFormat:@".%@", $2 ] ; 
				}
;

array:			'[' exprlist ']'			{ $$ = $2 ; }
;

%%
